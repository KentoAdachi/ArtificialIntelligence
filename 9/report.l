(setf (get 's 'neighbors) '(a d)
      (get 'a 'neighbors) '(s b d)
      (get 'b 'neighbors) '(a c e)
      (get 'c 'neighbors) '(b)
      (get 'd 'neighbors) '(s a e)
      (get 'e 'neighbors) '(b d f)
      (get 'f 'neighbors) '(e)
      (get 'nil 'neighbors) '(s)
)
(defun removecycle (atom list) 
  (cond ((null list) nil)
	((eq atom (car list)) (removecycle atom (cdr list) ) )
	(t (cons (car list) (removecycle atom (cdr list)) ) )
	) )

(defun dontagain (neighbors path)
  (cond ((atom path) (removecycle path neighbors))
	(t (road neighbors path))
	)
  )

(defun road (neighbors path)
  (dontagain (dontagain neighbors (cdr path)) (car path)))

(defun last_node (list)
  (cond ((atom list) list)
	(t (car list))
	)
  )

(defun get_neighbors (node)
  (get node 'neighbors) )

(defun extend2 (neighbors path)
  (cond ((null neighbors) nil)
	(t (cond ((eq neighbors nil) nil)
		 ((atom neighbors) (cons neighbors path))
		 (t (cons (cons (car neighbors) path) (extend2 (cdr neighbors) path)))
		 )
	   )
	)
  )

(defun my-extend (path)
  (extend2 (dontagain (get_neighbors (last_node path)) path) path))

(defun completep (finish list)
  (cond ((eq finish (car list)) t)
	(t nil)
	) )

(defun appends (list1 list2)
  (cond ((null list1) list2)
	(t (cons (car list1) (appends (cdr list1) list2)))
	) )

(defun my-endp (queue)
  (cond ((null queue) t)
	(t nil)))

(defun my-search (start finish queue)
  (cond ((my-endp queue) nil)
	((completep finish (car queue)) (reverse (car queue)))
	(t (my-search start finish (appends (my-extend (car queue)) (cdr queue))))
	) )
